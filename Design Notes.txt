Timecards - a small Windows app for tracking your time
======================================================

Summary
-------

At work I use a small app I made using Microsoft Access to track my time.  It's
got a simple window with two tabs:  one tab just has a three-column table for
data entry, and the other tab (which is hidden until you press a button at the
top of the form) is for summarizing the time you've spent.

In the first tab, the table has three columns:  a ticket number, a description,
and the time at which you started working on that ticket.  As a matter of
convention, I use a fake ticket number of "00000" to mean unbilled time, and a
handful of other fake ticket numbers for various things like meetings or self-
education.  For all other time, I enter the ticket number of the case I'm
working on - in our case, since we use JIRA for managing our development, I
enter the JIRA ticket number.  At my last job I used a similar ticket number.

The reporting tab asks for a date range, and then adds all the time together and
displays the total time by ticket number.  I use this to enter the time I've
spent on each ticket in JIRA.  I can also tell from this little report whether
I've spent too much time focused on non-productive work.

This little app has served me well for years.  However, it's always bothered me
that it's in Access, which means it has a fairly large memory footprint.  I
really don't need all the database power (and overhead) that comes with Access
for this little app.

So, I've started this open source project to produce an equivalent app using C#
and SQLite.  The goal is to have a stand-alone app with all the same features,
but with a much smaller footprint.  And if I stick to .NET Core, I should be
able to come up with an application that will work on both Windows and Linux -
and maybe even the Mac platform.  But we'll see.



09/04/2018
----------

Here are some initial criteria and constraints for this project.


Criteria

* The application should launch from a Windows shortcut.  If the database
  doesn't exist, it should create that right at the beginning.

* There should be a minimal set of options:

  - Whether to round the times to the nearest five minutes or to the nearest
    minute when entering a new line in the table;

  - A place for a list of "fake" ticket numbers and default descriptions to
    supply if that ticket number is entered.

* The data entry tab should have a date field for the day and should also
  display the day of the week for the date entered.  Below this should be the
  table for entering rows of time information.

* The data entry form should allow the user to edit and change the ticket
  number, description, and starting time on any row that was entered.

* The user should be able to add new rows to the bottom of the table, and should
  be able to delete any existing row.
  
* It would be nice if there was also a way to insert a row between two existing
  rows, so that if something was forgotten it could be entered without having to
  re-enter data for subsequent rows.

* The data entry tab should have a way of navigating from day to day so that the
  user could review the activity of previous days.

* The reporting tab should ask for a date range and then compute the total time
  spent for each ticket number for that date range.  The date range should
  default to the current day.

* The report should show the total time for each ticket in both minutes and in
  hours (rounded to quarter hours), and there should be total hours at the
  bottom of each of these two columns.


Constraints

* This should be a C# project using .NET Core.

* This should use SQLite as the database engine.  Check to make sure the SQLite
  library is available via NuGet.  Also check the licensing.  (SQLite itself is
  in the public domain, but I don't know about the .NET library that interfaces
  with it.)

* Some initial tests should be conducted to see if Windows Forms and controls
  will work on platforms other than Windows.  This may influence the decision to
  use Windows forms vs. some other UI library such as Qt.  Again, licensing
  should be kept in mind when choosing a library.



09/08/2018
----------

While Microsoft has announced that .NET Core version 3 will have UI components,
it wasn't available at the time I started this project.  I looked into using Qt,
GTK#, and Xamarin.Forms - and all of them have their detractions.  My overall
goal is to keep this project as simple as possible - so I'm going back to .NET
Framework and standard Windows forms.  I'll consider .NET Core again when
version 3 becomes available.



09/19/2018
----------

The biggest challenge so far has been the use of SQLite for a data store. Visual
Studio expects you to use MS SQL Server, of course, so that's always the easiest
path to take.  But with a little determination and some help from StackOverflow
and other sources, I came up with a system that works.  It uses EF and CodeFirst
to create the database on the fly with the first use.

The trickiest part was getting the settings right in app.config.  for those of
you who are interested in using SQLite in your .NET products, you're welcome to
use what I have in this project as an example.

Oddly enough, one of the supposed advantages of using SQLite is that it can work
with an "in-memory" database.  But you can't work with this when using Code
First because the database disappears as soon as the connection is closed - and
since EF and ADO.NET are designed not to keep the connection open all the time,
this doesn't work.  I found a note by the SQLite CodeFirst developers saying
they're not going to address this.  (And I don't blame them.)

But I will say that EF works rather nicely with SQLite once it's configured
properly.  For testing, I just added another connection string - and in the test
setup, I make sure to delete this test database file so that the contents are
predictable.



10/27/2018
----------

I've got the Core project fairly complete, the Data project fairly complete, and
I've got the UI project nearly complete.  The main task remaining is wiring
everything up so that it all works together.

I wanted this application to follow something like the Onion or Hexagonal
architecture, in that the inner Core project would have no references to the
outer "layers" -- namely the Data project and the UI project -- while the outer
layers would have a reference to the inner Core project (but not to each other).

So now the challenge will be to "wire up" the controls to data without violating
this architecture.  I'm not quite sure how I'll do that yet.  I imagine that the
startup program will have to instantiate the data tier, and perhaps make it
available to the Core project via events or something.


The UI project was surprisingly challenging.  I used a DataGridView control to
hold the activities the user will enter.  I learned how to host custom controls
for the Code and Time columns in the grid.  I also learned how to access the
vertical scroll bar control inside the grid so that I could know when it becomes
visible, so I can use its width to adjust the width of the columns.


There's been a design change nagging me since I started this project.  My
original Access project stored the time as a string (e.g., "14:30") -- and I
kept that idea in the original layout of the SQLite table holding activities.
However, I made sure to write the Core Activity class so that you could access
the time as either a string or as the number of minutes since midnight.

As I've been writing this, I've been wondering what the best way would be to
support people who work past midnight.  I've decided to change the storage so
the number of minutes is stored rather than the time.  (The Activity class
should probably also have an "after midnight" flag or something, so that
changing the time doesn't move the activity to the early morning of the previous
day.)

This way, not only will I be able to handle working after midnight, I will also
be in better shape for supporting other time formats besides a 24-hour clock.
This will also make it easier to query in time order from the table.


